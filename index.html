<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Maze Generator</title>
    <script src="Eller.js"></script>
    <script src="AStarCustomMap.js"></script>
</head>

<body style="text-align: center;">
    Width: <select id="mazeWidth"></select> Height: <select id="mazeHeight"></select>
    <input type="button" onclick="onSubmitForm()" value="Submit" />
    <input type="button" id="btnPath" onclick="startPath()" value="Path" /><br />
    <canvas id="mazeCanvas" width="600px" height="600px"></canvas>
    <div id="message" style="text-align: center;">Click Path button to setup start and end point.</div>
    <script>
        const MAZE_MIN_LENGTH = 5;
        const MAZE_MAX_LENGTH = 30;
        let selectMazeWidth = document.querySelector('#mazeWidth');
        let selectMazeHeight = document.querySelector('#mazeHeight');
        let selectMazeOptionStr = '';
        for (let i = MAZE_MIN_LENGTH; i <= MAZE_MAX_LENGTH; i++) {
            selectMazeOptionStr += '<option value="' + i + '">' + i + '</option>';
        }
        selectMazeWidth.innerHTML = selectMazeOptionStr;
        selectMazeHeight.innerHTML = selectMazeOptionStr;

        let mazeWidth = 10;
        let mazeHeight = 10;
        let mazeMargin = 2; //px
        let mazeGridWidth = 30; //px
        let eller = new EllerMaze(mazeWidth, mazeHeight);
        let maze = null;

        let mazeCanvas = document.getElementById('mazeCanvas');
        let context = mazeCanvas.getContext('2d');
        mazeCanvas.addEventListener('click', onMazeCanvasClick);
        let message = document.getElementById('message');

        let points = [];
        let link = [];

        let astar = null;
        let path = []

        const PATH_DONE = 0;
        const PATH_SELECT_START = 1;
        const PATH_SELECT_END = 2;
        let pathStatus = PATH_DONE;
        let pathStart = null;
        let pathEnd = null;
        let btnPath = document.getElementById('btnPath');
        let imageData = null;


        selectMazeWidth.value = mazeWidth + '';
        selectMazeHeight.value = mazeHeight + '';
        onSubmitForm();

        function onSubmitForm() {
            context.clearRect(0, 0, mazeCanvas.width, mazeCanvas.height);
            mazeWidth = parseInt(selectMazeWidth.value, 10);
            mazeHeight = parseInt(selectMazeHeight.value, 10);
            setupeMaze(mazeWidth, mazeHeight);
        }
        function startPath() {
            changeMazePathStatus();
        }

        function changeMazePathStatus() {
            switch (pathStatus) {
                case PATH_DONE:
                    pathStatus = PATH_SELECT_START;
                    context.putImageData(imageData, 0, 0);
                    btnPath.disabled = true;
                    message.innerText = 'Click anywhere in maze to select start point.';
                    break;
                case PATH_SELECT_START:
                    pathStatus = PATH_SELECT_END;
                    btnPath.disabled = true;
                    message.innerText = 'Click anywhere in maze to select end point.';
                    break;
                case PATH_SELECT_END:
                    pathStatus = PATH_DONE;
                    setupPath(pathStart, pathEnd);
                    btnPath.disabled = false;
                    message.innerText = 'Click Path button to setup start and end point.';
                    break;
            }
        }

        function onMazeCanvasClick(e) {
            if (pathStatus == PATH_DONE) {
                return;
            }
            const elementRelativeX = e.offsetX;
            const elementRelativeY = e.offsetY;
            const canvasRelativeX = elementRelativeX * mazeCanvas.width / mazeCanvas.clientWidth;
            const canvasRelativeY = elementRelativeY * mazeCanvas.height / mazeCanvas.clientHeight;

            let x = Math.floor((canvasRelativeX - mazeMargin) / mazeGridWidth);
            let y = Math.floor((canvasRelativeY - mazeMargin) / mazeGridWidth);
            console.log(pathStatus + '=>' + x + ',' + y);
            context.fillStyle = "red";
            context.fillRect(
                x * mazeGridWidth + mazeMargin + (mazeGridWidth / 4),
                y * mazeGridWidth + mazeMargin + (mazeGridWidth / 4),
                mazeGridWidth / 2,
                mazeGridWidth / 2);

            if (pathStatus === PATH_SELECT_START) {
                pathStart = points.find(p => p.X === x && p.Y === y);
                changeMazePathStatus();
            } else if (pathStatus === PATH_SELECT_END) {
                pathEnd = points.find(p => p.X === x && p.Y === y);
                changeMazePathStatus();
            }
        }

        function setupeMaze(width, height, vBias = 0.5, hBias = 0.5) {
            eller.LengthOfRow = width;
            eller.NumberOfRow = height;
            mazeCanvas.width = mazeMargin * 2 + mazeGridWidth * width;
            mazeCanvas.height = mazeMargin * 2 + mazeGridWidth * height;
            maze = eller.GenerateMaze();
            drawMaze();
            toPathMap(maze);
            imageData = context.getImageData(0, 0, mazeCanvas.width, mazeCanvas.height);
        }

        function setupPath(start, end) {
            astar = new AStarCustomMap(points, link);
            path = astar.GetPath(start, end);
            drawPath(path);
        }

        function drawMaze() {
            context.beginPath();
            context.strokeStyle = 'black';
            //畫上邊和左邊的線
            context.moveTo(mazeMargin, mazeMargin);
            context.lineTo(mazeMargin + mazeGridWidth * mazeWidth, mazeMargin);

            context.moveTo(mazeMargin, mazeMargin);
            context.lineTo(mazeMargin, mazeMargin + mazeGridWidth * mazeHeight);

            //依據每個cell右邊和下邊畫線
            for (let i = 0; i < maze.length; i++) {
                for (let j = 0; j < maze[i].Cells.length; j++) {
                    if (maze[i].Cells[j].RightWall) {
                        context.moveTo(mazeMargin + (j + 1) * mazeGridWidth, mazeMargin + i * mazeGridWidth);
                        context.lineTo(mazeMargin + (j + 1) * mazeGridWidth, mazeMargin + (i + 1) * mazeGridWidth);
                    }
                    if (maze[i].Cells[j].BottomWall) {
                        context.moveTo(mazeMargin + j * mazeGridWidth, mazeMargin + (i + 1) * mazeGridWidth);
                        context.lineTo(mazeMargin + (j + 1) * mazeGridWidth, mazeMargin + (i + 1) * mazeGridWidth);
                    }
                }
            }
            context.stroke();
            context.closePath();
        }

        function drawPath(path) {
            context.beginPath();
            context.strokeStyle = 'red';
            let pointPath = path.map(x => points.find(y => y.Id === x));
            for (let i = 0; i < pointPath.length - 1; i++) {
                context.moveTo(mazeMargin + mazeGridWidth / 2 + pointPath[i].X * mazeGridWidth, mazeMargin + mazeGridWidth / 2 + pointPath[i].Y * mazeGridWidth);
                context.lineTo(mazeMargin + mazeGridWidth / 2 + pointPath[i + 1].X * mazeGridWidth, mazeMargin + mazeGridWidth / 2 + pointPath[i + 1].Y * mazeGridWidth)
            }
            context.stroke();
            context.closePath();
        }

        function toPathMap(maze) {
            points = [];
            link = [];
            for (let i = 0; i < maze.length; i++) {
                for (let j = 0; j < maze[i].Cells.length; j++) {
                    let id = maze[i].Cells.length * i + j;
                    points.push(new Point(id, j, i));
                    if (!maze[i].Cells[j].RightWall) {
                        link.push([id, id + 1]);
                    }
                    if (!maze[i].Cells[j].BottomWall) {
                        link.push([id, id + maze[i].Cells.length]);
                    }
                }
            }
        }
    </script>
</body>

</html>